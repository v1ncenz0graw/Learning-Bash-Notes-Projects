Status: On-Going

Tags: #bash #linux #shell 

Links: [1-Basics](1-Basics.md) [README](README.md) [3-Setting_Up](3-Setting_Up.md) 
___

# Flow Control and Text Processing
## A) Test Operators
Bash lets us selectively execute commands when certain conditions of interest are met. We can use test operators to craft a wide variety of conditions, such as whether one value equals another value, whether a file is of a certain type, or whether one value is greater than another. We often rely on such tests to determine whether to continue running a block of code, so being able to construct them is fundamental to bash programming.

- File test Operators:

| Operator | Description                                       |
| :------: | ------------------------------------------------- |
|    -d    | Checks whether the file is a directory            |
|    -r    | Checks whether the file is readable               |
|    -x    | Checks whether the file is executable             |
|    -w    | Checks whether the file is writable               |
|    -f    | Checks whether the file is a regular file         |
|    -s    | Checks whether the file size is greater than zero |

-  String Comparison Operators:

| Operator | Description                                                  |
| :------: | ------------------------------------------------------------ |
|    =     | Checks whether a string is equal to another string           |
|    ==    | Synonym of = when used within [[]] constructs                |
|    !=    | Checks whether a string is not equal to another string       |
|    <     | Checks whether a string comes before another string<br>(A-z) |
|    >     | Checks whether a string comes after another string<br>(A-z)  |
|    -z    | Checks whether a string is null                              |
|    -n    | Checks whether a string is not null                          |

- Integer Comparison Operators

| Operator | Description                                        |
| :------: | -------------------------------------------------- |
|   -eq    | Checks whether a number is equal to another number |
|   -ne    | Checks whether a number is not equal               |
|   -ge    | Checks whether a number is greater than/equal to   |
|   -gt    | Checks whether a number is greater than            |
|   -lt    | Checks whether a number is less than               |
|   -le    | Checks whether a number is less than/ equal to     |

---

## B) if Conditions
 Syntax:
```bash
#!/usr/bin/env bash

if [[ condition ]]; then
	# Code Block if condition is true
else
	# Code Block if condition is flase
fi

# In some operating systems, such as those often used in containers,
# the default shell might not necessarily be bash.
# To account for these cases, you may want to use single square 
# brackets ([...]) rather than double to enclose your condition.
# This use of single brackets meets the Portable Operating System Interface 
# standard and should work on almost any Unix derivative, including Linux.
```

We can check for multiple conditions within one if condition using `&&` and  `||` operators:
```bash
#!/usr/bin/env bash

if [ condition_1 && condition_2 ] then
	.....
else
	.....
fi
```

As we continue with bash scripting, not all of commands will end with success due to some reasons like:
- Lack of permissions
- Absence of command package
- Lack of space when downloading package
- Lack of data connection

Thanks to if condition we can test the exit code of commands:
```bash
if touch test123; then
	echo "SUCCESS: file created"
else
	echo "ERROR: file already exists"
fi
```

We can use `else if` as `elif`

---

## C) Functions
Syntax:
```bash
#!/usr/bin/env bash

check_if_root(){
	if [ "${EUID}" -eq "0" ]; then
		return 0
	else 
		return 1
	fi
}

if check_if_root; then
	echo "User is root!"
else 
	ECHO "User is not root!"
fi
```

Accepting Arguments:
```bash
#!/usr/bin/env bash

print_args(){
	echo "First: ${1}, Second: ${2}, Third: ${3}"
}

print_args bir ikki uch
```

---

## D) Loops & Loop Control
### _while_:
In bash, while loops allow you to run a code block until a test returns a successful exit status code.

Syntax:
```bash
while some_condition; do
	# Code block while condition is true
done
```

Example:
```bash
#!/usr/bin/env bash

target="browser_history.log"

while [ ! -f "${target}" ]; do
	echo "Logs are clear"
done

rm -rf ${target}
echo "Evidances are destroyed successfully!!!"
```
(You already get the idea, right?)

### _until_: 
Whereas _while_ runs as long as condition succeeds, _until_ runs as long as condition is fails

Syntax: 
```bash
until some_condition; do
	# Code block until condition succeeds
done
```
and usage is pretty same as _while_

### _for_:
The for loop iterates over a sequence, such as a list of filenames or variables, or even a group of values generated by running a command. Inside the for loop, we define a block of commands that are run against each value in the list, and each value in the list is assigned to a variable name we define.

Syntax:
```bash
for variable_name in LIST; do
	# Run some commands for each item in the sequence
done
```

A simple way to use a for loop is to execute the same command multiple
times:
```bash
#!/usr/bin/env bash

for ip_address in "$@"; do
	echo "Taking some action on IP address: ${ip_address}"
done

```

### _break_ & _continue_
Using _break,_ we can leave the loop and advance to the next code block:
```bash
#/usr/bin/env bash

while true; do
	echo "Go get life"
	break
done
```

The _continue_ statement is used to jump to the next iteration of a loop.
We can use it to skip a certain value in a sequence:
```bash
#/usr/bin/env bash

for file_name in file_name*; do
	
	if [ "${file}" == "file_name2" ]; then
		echo "Skipping the second file!"
		continue
	fi

	echo "${RANDOM}" > "${file}"
done
```

### _case_ Statements
In bash, case statements allow you to test multiple conditions in a cleaner way by using more readable syntax. Often, they help you avoid many if conditions, which can become harder to read as they grow in size.

Syntax:
```bash
case EXPRESSION in
	PATTERN1)
		# Write you GF's name if the first condition is met
	;;
	PATTERN2)
		# no GF? Are you gay?
	;;
esac
```

Example:
```bash
#!/usr/bin/env bash

IP="${1}"

case ${IP} in
	192.168.*)
		echo "Network is 192.168.x.x"
	;;
	10.10.*)
		echo "Network is 10.0.x.x"
	;;
	*)
		echo "Couldn't identify the network"
	;;
esac
```

---

## E) Text Processing and Parsing
#####  _you can find used log file on materials folder, if you wanna try out things by yourself_
### _grep_
The grep command is one of the most popular Linux commands out there today. We use grep to filter out information of interest from streams.

Basic usage:
`grep "35.237.4.214" log.txt`

Sort multiple patterns:
`grep "35.237.4.214\|13.66.139.0" log.txt`
or
`grep -e "35.237.4.214" -e "13.66.139.0" log.txt`

By default, grep is case sensitive:
`ps | grep -i tty` not anymore

Or we can exclude the line that contains defined pattern:
`grep -v "35.237.4.214" log.txt`

Sometimes output becomes to long reason _grep_ prints whole line where pattern is found:
`grep -o "35.237.4.214" log.txt` here's your solution

### _awk_
The _awk_ command is a data processing and extraction Swiss Army knife. You can use it to identify and return specific fields from a file.

What if we need to print just the IP addresses from this file?
`awk '{print $1}' log.txt`

Using same syntax, we can print additional fields:
`awk '{print $1,$3,$NF}' log.txt` ($NF = last field)

By default, _awk_ treats spaces or tabs as separators or delimiters.
Here's how you can modify it to comma
`awk -F',' '{print $1}' example_csv.txt`

Print 10 lines of file:
`awk 'NR < 10' log.txt`

Now imagine combining _grep_ & _awk_ 
Let's say We want to find HTTP paths requested by 42.236.10.117:
`grep "42.236.10.117" log.txt | awk '{print $7}'`

### _sed_
The _sed_ (stream editor) command takes actions on text. For example, it can replace the text in a file, modify the text in a commandâ€™s output, and even delete selected lines from files.

Let's replace any mentions of the word Mozilla with the word Godzilla in the log.txt file.
`sed 's/Mozilla/Godzilla/g' log.txt`

It will not save changes. So redirection:
`sed 's/Mozilla/Godzilla/g' log.txt > newlog.txt`

We could also use _sed_ to remove any white-space from the file with the `/ //` syntax, which will replace white-space with nothing:
`sed 's/ //g'`

there are so much to write so use `man sed` to learn more.

---

## F) Job Control

___
## References: 
- Full List of file test operators are [here](https://ss64.com/bash/test.html)
- 

Created:: 2024-11-28 10:14